/* version 2.2 (PM, 28/3/15) : ajout d'un pas de temps parametrable */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <string.h>

#define NBFILS 5
#define DUREE 9		/* duree de vie de chaque fils, en pas  de temps (ticks) */
#define LMAX 256

int pids[NBFILS];
int pipes[NBFILS][2];
int numfils = NBFILS;

void handler(int sig) {
	int pid, status, k;
	
	// Tant qu'il y a des fils terminés à traiter
	while((pid = waitpid(-1, &status, WNOHANG)) > 0) {
		// Sélection du numéro du fils terminé
		k = 0;
		while(k < NBFILS && pids[k] != pid) {
			k++;
		}
		
		// Dire que le fils a terminé
		printf("Le fils %d (de pid %d) a terminé.\n", k+1, pid);
		// Enregistrer la terminaison du fils
		pids[k] = 0;
	}
}

int main (int argc, char *argv[]) {
	int i, j, k, tick, numfils;
	int status, pid, filsactifs;
	char buf[LMAX];
	int rd;
	
	/* Mise en place des paramètres par défaut */
	if (!((argc == 2) && ((k=strtol(argv[1], (char **)NULL, 10))>0))){ /* atoi obsolete */
		k = 1;
		printf("utilisation : %s <pas de temps>\n", argv[0]);
		printf("Execution avec le pas par defaut (1 s)\n");
	}

	/* Création de NBFILS fils*/ 
	for (i = 0; i < NBFILS; i++) {
	
		/* Création du pipe pour discuter avec le fils */
		pipe(pipes[i]);
		
		/* Création du fils */
		switch (pid = fork()) {
			case -1 :
				perror ("Fork failed");
				exit (1);
			case 0 :
				/* Fermeture de la sortie du pipe pour le fils */
				close(pipes[i][0]);
				
				/* Redirection de la sortie standard du fils vers l'entrée du pipe */
				dup2(pipes[i][1], 1);
				
				/* Initialisation des paramètres du pipe */
				tick=0;
				numfils=i+1;
				
				/* durant k*DUREE secondes, chaque fils repete :
				- afficher numfils messages
				- s'endormir durant k*numfils secondes (k secondes après chaque message) */
				while(tick<k*DUREE) {
					for(j=0; j<numfils; j++) {
						sprintf(buf, "Temps %d - Fils %d - message  %d\n",tick+j*k, numfils, j);
						write(pipes[i][1], buf, strlen(buf));
						sleep (k);
					}
					tick+=k*numfils;
				}
				exit(0);
			default :
				/* Fermeture de l'entrée du pipe pour le père */
				close(pipes[i][1]);
				
				/* Lecture du pipe non bloquante */
				fcntl(pipes[i][0], F_SETFL, fcntl(pipes[i][0], F_GETFL) | O_NONBLOCK);
				
				/* Enregistrement du pid du fils */
				pids[i] = pid;
			;
		}
	}

	/* pere */
	// Ajout du handler pour la terminaison des fils
	signal(SIGCHLD, handler);
	
	// Tant qu'il y a des fils à traiter
	filsactifs = NBFILS;
	while(filsactifs > 0) {// Pour chaque fils
		for(i = 0; i < NBFILS; i++) {
			
			// Si le fils est encore à traiter
			if(pids[i] >= 0) {
				// Vider le pipe
				bzero(buf, LMAX);
				rd = read(pipes[i][0], &buf, LMAX);
				if(rd > 0) {
					printf("%s", buf);
				}
				// Si le fils viens de terminer
				if(pids[i] == 0) {
					pids[i] = -1;
					close(pipes[i][0]);
					filsactifs--;
				}
			}
		}
	}
}
















