(* le type abstrait *)
type 'a arbre_binomial =
	| Leaf of 'a
	| Node of 'a arbre_binomial * 'a * 'a arbre_binomial;;

(* singleton e: construit un arbre binomial contenant e *)
(* complexité : Theta(1) *)
(* résultat : un arbre binomial d'ordre 0 contenant e *)
val singleton : 'a -> 'a arbre_binomial;;

(* merge a1 a2: construit un arbre binomial union des 2 arbres a1 et a2 *)
(* complexité : Theta(1) *)
(* précondition : a1 et a2 ont le même ordre k *)
(* résultat : un arbre binomial d'ordre k+1, contenant les éléments de a1 et a2 *)
val merge : 'a arbre_binomial -> 'a arbre_binomial -> 'a arbre_binomial;;

(* get i a: renvoie le i-ème élément de l'arbre a *)
(* complexité : Theta(log (taille a)) *)
(* précondition : i in [0, taille de a[ *)
(* résultat : le i-ème élément *)
(* erreur : i est incorrect *)
val get : int -> 'a arbre_binomial -> 'a;;

(* set i v a: remplace le i-ème élément de l'arbre a par la valeur v *)
(* complexité : Theta(log (taille a)) *)
(* précondition : i in [0, taille de a[ *)
(* résultat : un arbre où le i-ème élément vaut v *)
(* erreur : i est incorrect *)
val set : int -> 'a -> 'a arbre_binomial -> 'a arbre_binomial;

(* le type abstrait *)
type 'a ral;;

(* la structure vide *)
val vide : 'a ral;;

(* ajout d'un élément en tête *)
val cons : 'a -> 'a ral -> 'a ral;;

(* head ral: renvoie le premier élément de ral *)
(* précondition : ral non vide *)
(* résultat : l'élément d'indice 0 de ral *)
(* erreur : ral vide *)
val head : 'a ral -> 'a;;

(* tail ral: renvoie la "queue" (au sens liste) de ral *)
(* précondition : ral non vide *)
(* résultat : la sous-structure de ral *)
(* composée des éléments d'indices [1, taille ral[ *)
(* erreur : ral vide *)
val tail : 'a ral -> 'a ral;;

(* get i ral: renvoie le ième élément de ral *)
(* précondition : i dans l'intervalle [0, taille ral[ *)
(* résultat : le ième élément *)
(* erreur : indice i incorrect *)
val get : int -> 'a ral -> 'a;;

(* set i v ral: remplace le ième élément de ral par v *)
(* précondition : i dans l'intervalle [0, taille ral[ *)
(* résultat : ral "modifié" *)
(* erreur : indice i incorrect *)
val set : int -> 'a -> 'a ral -> 'a ral;
